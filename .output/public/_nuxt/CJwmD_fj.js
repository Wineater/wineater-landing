import{B as T,H as F}from"./DuvFzeV8.js";import{M as H,j as P,N as L,O as j,P as x,L as z,Q as U,R as O,B as V,S as k,b as M,T as q,U as N,h as Q,V as K,W as X,X as Y,Y as h,_ as B,o as E,c as I,p as G,e as W,a as D,H as J,F as Z,v as A}from"./Bm-DOa51.js";const ee=e=>e==="defer"||e===!1;function ae(...e){var g;const n=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(n);let[s,c,t={}]=e;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=V(),l=c,y=()=>null,w=()=>a.isHydrating?a.payload.data[s]:a.static.data[s];t.server=t.server??!0,t.default=t.default??y,t.getCachedData=t.getCachedData??w,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0,t.deep=t.deep??H.deep,t.dedupe=t.dedupe??"cancel";const _=()=>t.getCachedData(s,a)!=null;if(!a._asyncData[s]||!t.immediate){(g=a.payload._errors)[s]??(g[s]=null);const i=t.deep?P:L;a._asyncData[s]={data:i(t.getCachedData(s,a)??t.default()),pending:P(!_()),error:j(a.payload._errors,s),status:P("idle")}}const r={...a._asyncData[s]};r.refresh=r.execute=(i={})=>{if(a._asyncDataPromises[s]){if(ee(i.dedupe??t.dedupe))return a._asyncDataPromises[s];a._asyncDataPromises[s].cancelled=!0}if((i._initial||a.isHydrating&&i._initial!==!1)&&_())return Promise.resolve(t.getCachedData(s,a));r.pending.value=!0,r.status.value="pending";const d=new Promise((u,o)=>{try{u(l(a))}catch(p){o(p)}}).then(async u=>{if(d.cancelled)return a._asyncDataPromises[s];let o=u;t.transform&&(o=await t.transform(u)),t.pick&&(o=se(o,t.pick)),a.payload.data[s]=o,r.data.value=o,r.error.value=null,r.status.value="success"}).catch(u=>{if(d.cancelled)return a._asyncDataPromises[s];r.error.value=k(u),r.data.value=M(t.default()),r.status.value="error"}).finally(()=>{d.cancelled||(r.pending.value=!1,delete a._asyncDataPromises[s])});return a._asyncDataPromises[s]=d,a._asyncDataPromises[s]},r.clear=()=>te(a,s);const v=()=>r.refresh({_initial:!0}),b=t.server!==!1&&a.payload.serverRendered;{const i=q();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;x(()=>{o.forEach(p=>{p()}),o.splice(0,o.length)}),z(()=>o.splice(0,o.length))}b&&a.isHydrating&&(r.error.value||_())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):i&&(a.payload.serverRendered&&a.isHydrating||t.lazy)&&t.immediate?i._nuxtOnBeforeMountCbs.push(v):t.immediate&&v();const d=N();if(t.watch){const o=U(t.watch,()=>r.refresh());d&&O(o)}const u=a.hook("app:data:refresh",async o=>{(!o||o.includes(s))&&await r.refresh()});d&&O(u)}const m=Promise.resolve(a._asyncDataPromises[s]).then(()=>r);return Object.assign(m,r),m}function te(e,n){n in e.payload.data&&(e.payload.data[n]=void 0),n in e.payload._errors&&(e.payload._errors[n]=null),e._asyncData[n]&&(e._asyncData[n].data.value=void 0,e._asyncData[n].error.value=null,e._asyncData[n].pending.value=!1,e._asyncData[n].status.value="idle"),n in e._asyncDataPromises&&(e._asyncDataPromises[n].cancelled=!0,e._asyncDataPromises[n]=void 0)}function se(e,n){const s={};for(const c of n)s[c]=e[c];return s}function ne(e,n,s){const[c={},t]=typeof n=="string"?[{},n]:[n,s],a=Q(()=>h(e)),l=c.key||K([t,typeof a.value=="string"?a.value:"",...re(c)]);if(!l||typeof l!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+l);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const y=l===t?"$f"+l:l;if(!c.baseURL&&typeof a.value=="string"&&a.value[0]==="/"&&a.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:w,lazy:_,default:r,transform:v,pick:b,watch:m,immediate:g,getCachedData:i,deep:d,dedupe:u,...o}=c,p=X({...Y,...o,cache:typeof c.cache=="boolean"?void 0:c.cache}),S={server:w,lazy:_,default:r,transform:v,pick:b,immediate:g,getCachedData:i,deep:d,dedupe:u,watch:m===!1?[]:[p,a,...m||[]]};let f;return ae(y,()=>{var $;($=f==null?void 0:f.abort)==null||$.call(f),f=typeof AbortController<"u"?new AbortController:{};const C=h(c.timeout);return C&&setTimeout(()=>f.abort(),C),(c.$fetch||globalThis.$fetch)(a.value,{signal:f.signal,...p})},S)}function re(e){var s;const n=[((s=h(e.method))==null?void 0:s.toUpperCase())||"GET",h(e.baseURL)];for(const c of[e.params||e.query]){const t=h(c);if(!t)continue;const a={};for(const[l,y]of Object.entries(t))a[h(l)]=h(y);n.push(a)}return n}const oe={},R=e=>(G("data-v-aa6ba8e6"),e=e(),W(),e),ce={class:"lds-ripple"},ie=R(()=>D("div",null,null,-1)),le=R(()=>D("div",null,null,-1)),ue=[ie,le];function de(e,n){return E(),I("div",ce,ue)}const fe=B(oe,[["render",de],["__scopeId","data-v-aa6ba8e6"]]),he="https://wineater-backend.vercel.app/",pe="Y3I8Pi1FruGjVmIBqpV24PtOLYjzdROuxWX9tCXh82zjz7uUPxV3ETvHhoeiLS17";async function ye(e,n){console.log(e,n);try{return(await ne(`${he}dish/recommendations`,{method:"POST",headers:{Authorization:`Bearer ${pe}`},body:{text:e,store:n}},"$zVUsFkll1w")).data}catch(s){throw console.error("Error fetching data from API:",s),s}}const _e={components:{Preloader:fe,Button:T,Header:F},data(){return{selectedLanguage:this.$i18n.locale,supportedLocales:this.$i18n.locales,searchQuery:"",results:[],loading:!1}},created(){},methods:{searchChange(e){this.searchQuery=e.target.value},openLink(e){window.open(e,"_blank")},async handleInput(){if(!this.loading){this.loading=!0;try{const e=this.$route.query.store,n=await ye(this.searchQuery,e);this.results=n,this.loading=!1}catch(e){console.error("Error in handleInput:",e)}}},clearResults(){this.results=[]}},mounted(){setTimeout(()=>{this.$refs.searchInput.focus()},100)}},me=D("div",{class:"playground"},[D("div",{id:"wineater-widget-conteiner"})],-1);function ve(e,n,s,c,t,a){const l=A("Header");return E(),I(Z,null,[J(l,{"show-links":!1}),me],64)}const Pe=B(_e,[["render",ve]]);export{Pe as default};
